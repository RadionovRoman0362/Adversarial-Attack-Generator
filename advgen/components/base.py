"""
Этот модуль определяет "контракты" или "интерфейсы" для всех взаимозаменяемых
компонентов состязательной атаки. Каждый компонент представлен в виде
абстрактного базового класса (ABC).

Любая конкретная реализация (например, CrossEntropyLoss или LinfProjector)
должна наследоваться от соответствующего базового класса и реализовывать
его абстрактные методы.

Это обеспечивает соблюдение принципов SOLID (в частности, Open/Closed и Liskov Substitution)
и позволяет главному классу AttackRunner работать с любым компонентом через
единый, стандартизированный интерфейс.
"""

from abc import ABC, abstractmethod
import torch
import torch.nn as nn
from typing import List


class Initializer(ABC):
    """
    Абстрактный класс для инициализации начального возмущения.
    Определяет, с какой точки начинается атака.
    """
    @abstractmethod
    def initialize(self, images: torch.Tensor, epsilon: float) -> torch.Tensor:
        """
        Создает начальную точку для атаки.

        :param images: Оригинальные изображения (батч), тензор формы (N, C, H, W).
        :param epsilon: Максимальная величина возмущения.
        :return: Изображения с примененным начальным возмущением.
        """
        pass

    def reset(self):
        """
        (Опционально) Сбрасывает внутреннее состояние.
        """
        pass


class Loss(ABC):
    """
    Абстрактный класс для функций потерь.
    Определяет, что именно атака пытается "сломать" в модели.
    """
    @abstractmethod
    def __call__(self, logits: torch.Tensor, labels: torch.Tensor) -> torch.Tensor:
        """
        Вычисляет значение потерь. Для атак мы это значение максимизируем.

        :param logits: Выходные логиты модели, тензор формы (N, num_classes).
        :param labels: Истинные метки, тензор формы (N).
        :return: Скалярный тензор со значением потерь.
        """
        pass

    def reset(self):
        """
        (Опционально) Сбрасывает внутреннее состояние.
        """
        pass


class GradientComputer(ABC):
    """
    Абстрактный класс для методов вычисления и/или модификации градиента.
    Определяет "направление" шага атаки.
    """
    @abstractmethod
    def compute(
        self,
        surrogate_model: nn.Module,
        images: torch.Tensor,
        labels: torch.Tensor,
        loss_fn: Loss,
        all_models: List[nn.Module] = None
    ) -> torch.Tensor:
        """
        Вычисляет градиент функции потерь по отношению к входным изображениям.

        :param surrogate_model: Атакуемая модель (обертка).
        :param images: Тензор изображений, по которому нужно вычислить градиент
                       (должен иметь requires_grad=True).
        :param labels: Истинные метки для изображений.
        :param loss_fn: Экземпляр функции потерь для вычисления loss.
        :param all_models: (Опционально) список моделей для градиентов, вычисляемых по нескольким моделям.
        :return: Тензор градиента той же формы, что и `images`.
        """
        pass

    def reset(self):
        """
        (Опционально) Сбрасывает внутреннее состояние.
        """
        pass


class Scheduler(ABC):
    """
    Абстрактный класс для планировщиков размера шага.
    Определяет, "как далеко" мы шагаем в направлении градиента на каждой итерации.
    """
    @abstractmethod
    def get_step(self, current_step: int, total_steps: int, **kwargs) -> float:
        """
        Возвращает размер шага для текущей итерации.

        :param current_step: Номер текущей итерации (начиная с 0).
        :param total_steps: Общее количество итераций в атаке.
        :param kwargs: Дополнительные параметры (например, 'loss' для адаптивных методов).
        :return: Размер шага (float).
        """
        pass

    def reset(self):
        """
        (Опционально) Сбрасывает внутреннее состояние планировщика,
        если оно есть (например, в адаптивных методах).
        """
        pass


class Projector(ABC):
    """
    Абстрактный класс для проекторов.
    Определяет, как удерживать состязательное возмущение в допустимых границах
    (например, в пределах L-infinity или L2 шара).
    """
    @abstractmethod
    def project(
        self,
        adv_images: torch.Tensor,
        original_images: torch.Tensor,
        epsilon: float
    ) -> torch.Tensor:
        """
        Проецирует возмущение, чтобы оно не выходило за рамки эпсилон.

        :param adv_images: Текущие состязательные изображения после шага градиента.
        :param original_images: Оригинальные изображения.
        :param epsilon: Максимально допустимая норма возмущения.
        :return: Состязательные изображения, спроецированные обратно
                 в эпсилон-окрестность и валидный диапазон [0, 1].
        """
        pass

    def reset(self):
        """
        (Опционально) Сбрасывает внутреннее состояние.
        """
        pass


class UpdateRule(ABC):
    """
    Абстрактный класс для правил обновления состязательного примера.
    Определяет, как именно градиент и размер шага применяются для
    модификации изображения на каждой итерации. Это последний шаг
    в вычислении итеративного обновления перед проекцией.
    """
    @abstractmethod
    def update(self, images: torch.Tensor, grad: torch.Tensor, step_size: float) -> torch.Tensor:
        """
        Применяет правило обновления к изображениям.

        :param images: Текущие состязательные изображения (тензор).
        :param grad: Тензор градиента, вычисленный GradientComputer'ом.
        :param step_size: Размер шага, определенный Scheduler'ом.
        :return: Обновленный тензор состязательных изображений.
        """
        pass

    def reset(self):
        """
        (Опционально) Сбрасывает внутреннее состояние.
        """
        pass